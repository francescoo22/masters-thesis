@article{GenevaConvention,
author = {Hogg, John and Lea, Doug and Wills, Alan and deChampeaux, Dennis and Holt, Richard},
title = {The Geneva convention on the treatment of object aliasing},
year = {1992},
issue_date = {April 1992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {2},
issn = {1055-6400},
url = {https://doi.org/10.1145/130943.130947},
doi = {10.1145/130943.130947},
abstract = {Aliasing has been a problem in both formal verification and practical programming for a number of years. To the formalist, it can be annoyingly difficult to prove the simple Hoare formula {x = true} y := false {x = true}. If x and y refer to the same boolean variable, i.e., x and y are aliased, then the formula will not be valid, and proving that aliasing cannot occur is not always straightforward. To the practicing programmer, aliases can result in mysterious bugs as variables change their values seemingly on their own. A classic example is the matrix multiply routine mult(left, right, result) which puts the product of its first two parameters into the third. This works perfectly well until the day some unsuspecting programmer writes the very reasonable statement mult(a, b, a). If the implementor of the routine did not consider the possibility that an argument may be aliased with the result, disaster is inevitable.},
journal = {SIGPLAN OOPS Mess.},
month = {apr},
pages = {11–16},
numpages = {6}
}

@article{zimmerman2023latte,
  title={Latte: Lightweight Aliasing Tracking for Java},
  author={Zimmerman, Conrad and Gamboa, Catarina and Fonseca, Alcides and Aldrich, Jonathan},
  journal={arXiv preprint arXiv:2309.05637},
  year={2023}
}

@article{boyland2001alias,
  title={Alias burying: Unique variables without destructive reads},
  author={Boyland, John},
  journal={Software: Practice and Experience},
  volume={31},
  number={6},
  pages={533--553},
  year={2001},
  publisher={Wiley Online Library}
}

@InProceedings{An-Entente-Cordiale,
author="Marshall, Daniel
and Vollmer, Michael
and Orchard, Dominic",
editor="Sergey, Ilya",
title="Linearity and Uniqueness: An Entente Cordiale",
booktitle="Programming Languages and Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="346--375",
abstract="Substructural type systems are growing in popularity because they allow for a resourceful interpretation of data which can be used to rule out various software bugs. Indeed, substructurality is finally taking hold in modern programming; Haskell now has linear types roughly based on Girard's linear logic but integrated via graded function arrows, Clean has uniqueness types designed to ensure that values have at most a single reference to them, and Rust has an intricate ownership system for guaranteeing memory safety. But despite this broad range of resourceful type systems, there is comparatively little understanding of their relative strengths and weaknesses or whether their underlying frameworks can be unified. There is often confusion about whether linearity and uniqueness are essentially the same, or are instead `dual' to one another, or somewhere in between. This paper formalises the relationship between these two well-studied but rarely contrasted ideas, building on two distinct bodies of literature, showing that it is possible and advantageous to have both linear and unique types in the same type system. We study the guarantees of the resulting system and provide a practical implementation in the graded modal setting of the Granule language, adding a third kind of modality alongside coeffect and effect modalities. We then demonstrate via a benchmark that our implementation benefits from expected efficiency gains enabled by adding uniqueness to a language that already has a linear basis.",
isbn="978-3-030-99336-8"
}

@article{aldrich2002alias,
  title={Alias annotations for program understanding},
  author={Aldrich, Jonathan and Kostadinov, Valentin and Chambers, Craig},
  journal={ACM SIGPLAN Notices},
  volume={37},
  number={11},
  pages={311--330},
  year={2002},
  publisher={ACM New York, NY, USA}
}

@INPROCEEDINGS{1029817,
  author={Reynolds, J.C.},
  booktitle={Proceedings 17th Annual IEEE Symposium on Logic in Computer Science}, 
  title={Separation logic: a logic for shared mutable data structures}, 
  year={2002},
  volume={},
  number={},
  pages={55-74},
  keywords={Data structures;Computer science;Programmable logic arrays;Reflection;Logic programming;Computer languages;Logic arrays;Arithmetic;Artificial intelligence;Bibliographies},
  doi={10.1109/LICS.2002.1029817}}


@inproceedings{MuellerSchwerhoffSummers16,
  author      = {P. M{\"u}ller and M. Schwerhoff and A. J. Summers},
  title       = {Viper: A Verification Infrastructure for Permission-Based Reasoning},
  booktitle   = {Verification, Model Checking, and Abstract Interpretation (VMCAI)},
  editor      = {B. Jobstmann and K. R. M. Leino},
  year        = {2016},
  publisher   = {Springer-Verlag},
  series      = {LNCS},
  pages       = {41-62},
  volume      = {9583},
  url = {https://doi.org/10.1007/978-3-662-49122-5_2},
  urltext = {[Publisher]}
}

@inproceedings{AstrauskasBilyFialaGrannanMathejaMuellerPoliSummers22,
  author = {V. Astrauskas and A. B\'il\'y and J. Fiala and Z. Grannan and C. Matheja and P. M\"uller and F. Poli and A. J. Summers},
  title = {The Prusti Project: Formal Verification for Rust},
  booktitle = {NASA Formal Methods (14th International Symposium)},
  pages={88--108},
  year = {2022},
  publisher={Springer},
  url={https://link.springer.com/chapter/10.1007/978-3-031-06773-0_5},
  urltext   = {[Publisher]}
}

@InProceedings{WolfArquintClochardOortwijnPereiraMueller21,
  author       = {F. A. Wolf and L. Arquint and M. Clochard and W. Oortwijn and J. C. Pereira and P. M\"uller},
  title        = {{G}obra: Modular Specification and Verification of Go Programs},
  booktitle    = {Computer Aided Verification (CAV)},
  editor="Silva, Alexandra and Leino, K. Rustan M.",
  series       = {LNCS},
  volume       = {12759},
  publisher="Springer International Publishing",
  pages="367--379",
  year         = {2021},
  url          = {https://link.springer.com/chapter/10.1007/978-3-030-81685-8_17},
  urltext      = {[Publisher]},
  url1         = {https://ucl-pplv.github.io/CAV21/poster_P_186/#tab-extended},
  url1text     = {[Talk]}
}

@inproceedings{eilers2018nagini,
  title={Nagini: a static verifier for Python},
  author={Eilers, Marco and M{\"u}ller, Peter},
  booktitle={Computer Aided Verification: 30th International Conference, CAV 2018, Held as Part of the Federated Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings, Part I 30},
  pages={596--603},
  year={2018},
  organization={Springer}
}

@online{Kotlin,
  author       = {JetBrains},
  title        = {Kotlin Programming Language},
  year         = {2024},
  url          = {https://kotlinlang.org/},
}

@misc{FormVerPlugin,
  title = {Formal Verification Plugin for Kotlin},
  year = {2024},
  note = {GitHub repository},
  url = {https://github.com/jesyspa/kotlin/tree/formal-verification/plugins/formal-verification},
}

@article{Rust,
author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
title = {RustBelt: securing the foundations of the Rust programming language},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158154},
doi = {10.1145/3158154},
abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {66},
numpages = {34},
keywords = {Rust, concurrency, logical relations, separation logic, type systems}
}

@book{Aliasing-OOP,
editor = {Clarke, Dave and Noble, James and Wrigstad, Tobias},
title = {Aliasing in Object-Oriented Programming: types, analysis, and verification},
year = {2013},
isbn = {9783642369452},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
}

@article{Featherweight-Java,
author = {Igarashi, Atsushi and Pierce, Benjamin C. and Wadler, Philip},
title = {Featherweight Java: a minimal core calculus for Java and GJ},
year = {2001},
issue_date = {May 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {23},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/503502.503505},
doi = {10.1145/503502.503505},
abstract = {Several recent studies have introduced lightweight versions of Java: reduced languages in which complex features like threads and reflection are dropped to enable rigorous arguments about key properties such as type safety. We carry this process a step further, omitting almost all features of the full language (including interfaces and even assignment) to obtain a small calculus, Featherweight Java, for which rigorous proofs are not only possible but easy. Featherweight Java bears a similar relation to Java as the lambda-calculus does to languages such as ML and Haskell. It offers a similar computational "feel," providing classes, methods, fields, inheritance, and dynamic typecasts with a semantics closely following Java's. A proof of type safety for Featherweight Java thus illustrates many of the interesting features of a safety proof for the full language, while remaining pleasingly compact. The minimal syntax, typing rules, and operational semantics of Featherweight Java make it a handy tool for studying the consequences of extensions and variations. As an illustration of its utility in this regard, we extend Featherweight Java with generic classes in the style of GJ (Bracha, Odersky, Stoutamire, and Wadler) and give a detailed proof of type safety. The extended system formalizes for the first time some of the key features of GJ.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {may},
pages = {396–450},
numpages = {55},
keywords = {Compilation, Java, generic classes, language design, language semantics}
}

TO BE ADDED PROBABLY
- reachability types
- capabilities for uniqueness and borrowing 
- separation logic
- our repository