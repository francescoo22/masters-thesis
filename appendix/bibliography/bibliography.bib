@article{GenevaConvention,
author = {Hogg, John and Lea, Doug and Wills, Alan and deChampeaux, Dennis and Holt, Richard},
title = {The Geneva convention on the treatment of object aliasing},
year = {1992},
issue_date = {April 1992},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {2},
issn = {1055-6400},
url = {https://doi.org/10.1145/130943.130947},
doi = {10.1145/130943.130947},
abstract = {Aliasing has been a problem in both formal verification and practical programming for a number of years. To the formalist, it can be annoyingly difficult to prove the simple Hoare formula {x = true} y := false {x = true}. If x and y refer to the same boolean variable, i.e., x and y are aliased, then the formula will not be valid, and proving that aliasing cannot occur is not always straightforward. To the practicing programmer, aliases can result in mysterious bugs as variables change their values seemingly on their own. A classic example is the matrix multiply routine mult(left, right, result) which puts the product of its first two parameters into the third. This works perfectly well until the day some unsuspecting programmer writes the very reasonable statement mult(a, b, a). If the implementor of the routine did not consider the possibility that an argument may be aliased with the result, disaster is inevitable.},
journal = {SIGPLAN OOPS Mess.},
month = {apr},
pages = {11–16},
numpages = {6}
}

@article{beyondGenevaConvention,
  title={Beyond the geneva convention on the treatment of object aliasing},
  author={Clarke, Dave and Noble, James and Wrigstad, Tobias},
  journal={Aliasing in Object-Oriented Programming. Types, Analysis and Verification},
  pages={1--6},
  year={2013},
  publisher={Springer}
}


@article{zimmerman2023latte,
  title={Latte: Lightweight Aliasing Tracking for Java},
  author={Zimmerman, Conrad and Gamboa, Catarina and Fonseca, Alcides and Aldrich, Jonathan},
  journal={arXiv preprint arXiv:2309.05637},
  year={2023}
}

@article{boyland2001alias,
  title={Alias burying: Unique variables without destructive reads},
  author={Boyland, John},
  journal={Software: Practice and Experience},
  volume={31},
  number={6},
  pages={533--553},
  year={2001},
  publisher={Wiley Online Library}
}

@InProceedings{An-Entente-Cordiale,
author="Marshall, Daniel
and Vollmer, Michael
and Orchard, Dominic",
editor="Sergey, Ilya",
title="Linearity and Uniqueness: An Entente Cordiale",
booktitle="Programming Languages and Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="346--375",
abstract="Substructural type systems are growing in popularity because they allow for a resourceful interpretation of data which can be used to rule out various software bugs. Indeed, substructurality is finally taking hold in modern programming; Haskell now has linear types roughly based on Girard's linear logic but integrated via graded function arrows, Clean has uniqueness types designed to ensure that values have at most a single reference to them, and Rust has an intricate ownership system for guaranteeing memory safety. But despite this broad range of resourceful type systems, there is comparatively little understanding of their relative strengths and weaknesses or whether their underlying frameworks can be unified. There is often confusion about whether linearity and uniqueness are essentially the same, or are instead `dual' to one another, or somewhere in between. This paper formalises the relationship between these two well-studied but rarely contrasted ideas, building on two distinct bodies of literature, showing that it is possible and advantageous to have both linear and unique types in the same type system. We study the guarantees of the resulting system and provide a practical implementation in the graded modal setting of the Granule language, adding a third kind of modality alongside coeffect and effect modalities. We then demonstrate via a benchmark that our implementation benefits from expected efficiency gains enabled by adding uniqueness to a language that already has a linear basis.",
isbn="978-3-030-99336-8"
}

@article{aldrich2002alias,
  title={Alias annotations for program understanding},
  author={Aldrich, Jonathan and Kostadinov, Valentin and Chambers, Craig},
  journal={ACM SIGPLAN Notices},
  volume={37},
  number={11},
  pages={311--330},
  year={2002},
  publisher={ACM New York, NY, USA}
}

// TODO: decide what to keep for separation logic

@INPROCEEDINGS{separationLogic1,
  author={Reynolds, J.C.},
  booktitle={Proceedings 17th Annual IEEE Symposium on Logic in Computer Science}, 
  title={Separation logic: a logic for shared mutable data structures}, 
  year={2002},
  volume={},
  number={},
  pages={55-74},
  keywords={Data structures;Computer science;Programmable logic arrays;Reflection;Logic programming;Computer languages;Logic arrays;Arithmetic;Artificial intelligence;Bibliographies},
  doi={10.1109/LICS.2002.1029817}}

@inproceedings{separationLogic2,
  title={Local reasoning about programs that alter data structures},
  author={O’Hearn, Peter and Reynolds, John and Yang, Hongseok},
  booktitle={Computer Science Logic: 15th International Workshop, CSL 2001 10th Annual Conference of the EACSL Paris, France, September 10--13, 2001, Proceedings 15},
  pages={1--19},
  year={2001},
  organization={Springer}
}

@article{separationLogic3,
author = {Ishtiaq, Samin S. and O'Hearn, Peter W.},
title = {BI as an assertion language for mutable data structures},
year = {2001},
issue_date = {March 2001},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {36},
number = {3},
issn = {0362-1340},
url = {https://doi.org/10.1145/373243.375719},
doi = {10.1145/373243.375719},
abstract = {Reynolds has developed a logic for reasoning about mutable data structures in which the pre- and postconditions are written in an intuitionistic logic enriched with a spatial form of conjunction. We investigate the approach from the point of view of the logic BI of bunched implications of O'Hearnand Pym. We begin by giving a model in which the law of the excluded middleholds, thus showing that the approach is compatible with classical logic. The relationship between the intuitionistic and classical versions of the system is established by a translation, analogous to a translation from intuitionistic logic into the modal logic S4. We also consider the question of completeness of the axioms. BI's spatial implication is used to express weakest preconditions for object-component assignments, and an axiom for allocating a cons cell is shown to be complete under an interpretation of triplesthat allows a command to be applied to states with dangling pointers. We make this latter a feature, by incorporating an operation, and axiom, for disposing of memory. Finally, we describe a local character enjoyed by specifications in the logic, and show how this enables a class of frame axioms, which say what parts of the heap don't change, to be inferred automatically.},
journal = {SIGPLAN Not.},
month = {jan},
pages = {14–26},
numpages = {13}
}

@inproceedings{Viper,
  author      = {P. M{\"u}ller and M. Schwerhoff and A. J. Summers},
  title       = {Viper: A Verification Infrastructure for Permission-Based Reasoning},
  booktitle   = {Verification, Model Checking, and Abstract Interpretation (VMCAI)},
  editor      = {B. Jobstmann and K. R. M. Leino},
  year        = {2016},
  publisher   = {Springer-Verlag},
  series      = {LNCS},
  pages       = {41-62},
  volume      = {9583},
  url = {https://doi.org/10.1007/978-3-662-49122-5_2},
  urltext = {[Publisher]}
}

@inproceedings{prusti1,
  author = {V. Astrauskas and A. B\'il\'y and J. Fiala and Z. Grannan and C. Matheja and P. M\"uller and F. Poli and A. J. Summers},
  title = {The Prusti Project: Formal Verification for Rust},
  booktitle = {NASA Formal Methods (14th International Symposium)},
  pages={88--108},
  year = {2022},
  publisher={Springer},
  url={https://link.springer.com/chapter/10.1007/978-3-031-06773-0_5},
  urltext   = {[Publisher]}
}

@InProceedings{prusti2,
  title = {Leveraging {R}ust Types for Modular Specification and Verification},
  author = {V. Astrauskas and P. M\"uller and F. Poli and A. J. Summers},
  booktitle = {Object-Oriented Programming Systems, Languages, and Applications (OOPSLA)},
  journal = {Proc. ACM Program. Lang.},
  issue_date = {October 2019},
  volume = {3},
  number = {OOPSLA},
  year = {2019},
  pages = {147:1--147:30},
  url = {http://doi.acm.org/10.1145/3360573},
  urltext = {[Publisher]},
  doi = {10.1145/3360573},
  publisher = {ACM},
  url = {https://www.youtube.com/watch?v=lfc08mntlB0},
  urltext = {[Talk]}
}

@InProceedings{gobra,
  author       = {F. A. Wolf and L. Arquint and M. Clochard and W. Oortwijn and J. C. Pereira and P. M\"uller},
  title        = {{G}obra: Modular Specification and Verification of Go Programs},
  booktitle    = {Computer Aided Verification (CAV)},
  editor="Silva, Alexandra and Leino, K. Rustan M.",
  series       = {LNCS},
  volume       = {12759},
  publisher="Springer International Publishing",
  pages="367--379",
  year         = {2021},
  url          = {https://link.springer.com/chapter/10.1007/978-3-030-81685-8_17},
  urltext      = {[Publisher]},
  url1         = {https://ucl-pplv.github.io/CAV21/poster_P_186/#tab-extended},
  url1text     = {[Talk]}
}

@inproceedings{nagini,
  title={Nagini: a static verifier for Python},
  author={Eilers, Marco and M{\"u}ller, Peter},
  booktitle={Computer Aided Verification: 30th International Conference, CAV 2018, Held as Part of the Federated Logic Conference, FloC 2018, Oxford, UK, July 14-17, 2018, Proceedings, Part I 30},
  pages={596--603},
  year={2018},
  organization={Springer}
}

@online{Kotlin,
  author       = {JetBrains},
  title        = {Kotlin Programming Language},
  year         = {2024},
  url          = {https://kotlinlang.org/},
}

@article{KotlinSpec,
  title={Kotlin language specification},
  author={Akhin, Marat and Belyaev, Mikhail},
  journal={Kotlin Language Specification},
  year={2021}
}

@misc{rustlang,
  title        = {The Rust Programming Language},
  url          = {https://www.rust-lang.org},
  year         = {2024},
  note         = {Accessed: 2024-08-06}
}

@online{ViperWebSite,
  author = {Department of Computer Science, ETH Zürich},
  title = {Viper Language},
  url = {https://www.pm.inf.ethz.ch/research/viper.html},
}

@misc{FormVerPlugin,
  title = {Formal Verification Plugin for Kotlin},
  year = {2024},
  note = {GitHub repository},
  url = {https://github.com/jesyspa/kotlin/tree/formal-verification/plugins/formal-verification},
}

@book{Aliasing-OOP,
editor = {Clarke, Dave and Noble, James and Wrigstad, Tobias},
title = {Aliasing in Object-Oriented Programming: types, analysis, and verification},
year = {2013},
isbn = {9783642369452},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg}
}

@article{reachability-types,
author = {Bao, Yuyan and Wei, Guannan and Bra\v{c}evac, Oliver and Jiang, Yuxuan and He, Qiyang and Rompf, Tiark},
title = {Reachability types: tracking aliasing and separation in higher-order functional programs},
year = {2021},
issue_date = {October 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {OOPSLA},
url = {https://doi.org/10.1145/3485516},
doi = {10.1145/3485516},
abstract = {Ownership type systems, based on the idea of enforcing unique access paths, have been primarily focused on objects and top-level classes. However, existing models do not as readily reflect the finer aspects of nested lexical scopes, capturing, or escaping closures in higher-order functional programming patterns, which are increasingly adopted even in mainstream object-oriented languages. We present a new type system, λ* , which enables expressive ownership-style reasoning across higher-order functions. It tracks sharing and separation through reachability sets, and layers additional mechanisms for selectively enforcing uniqueness on top of it. Based on reachability sets, we extend the type system with an expressive flow-sensitive effect system, which enables flavors of move semantics and ownership transfer. In addition, we present several case studies and extensions, including applications to capabilities for algebraic effects, one-shot continuations, and safe parallelization.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {139},
numpages = {32},
keywords = {type systems, reachability types, ownership types, effect systems, aliasing}
}

@article{uniqueness-logic,
  title={Uniqueness logic},
  author={Harrington, Dana},
  journal={Theoretical Computer Science},
  volume={354},
  number={1},
  pages={24--41},
  year={2006},
  publisher={Elsevier}
}


TO BE ADDED PROBABLY
- capabilities for uniqueness and borrowing 